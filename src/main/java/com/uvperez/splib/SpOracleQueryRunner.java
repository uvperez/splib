package com.uvperez.splib;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Types;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;

/**
 * QueryRunner subclass to make compatible with SP
 * written in PLSQL.
 * Supports SP calls through JDBC.
 * 
 * @author uperez
 * @since 25-06-2018
 *
 */
public class SpOracleQueryRunner extends QueryRunner {

    private static final int ORACLE_CURSOR_TYPE = -10;
    
    private boolean pmdKnownBroken;

    /**
     * Execute an SQL SELECT query with replacement parameters.  The
     * caller is responsible for closing the connection.
     * @param <T> The type of object that the handler returns
     * @param conn The connection to execute the query in.
     * @param sql The query to execute.
     * @param rsh The handler that converts the results into an object.
     * @param params The replacement parameters.
     * @return The object returned by the handler.
     * @throws SQLException if a database access error occurs
     */
    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {
        return this.<T>query(conn, false, sql, rsh, params);
    }

    /**
     * Execute an SQL SELECT query without any replacement parameters.  The
     * caller is responsible for closing the connection.
     * @param <T> The type of object that the handler returns
     * @param conn The connection to execute the query in.
     * @param sql The query to execute.
     * @param rsh The handler that converts the results into an object.
     * @return The object returned by the handler.
     * @throws SQLException if a database access error occurs
     */
    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {
        return this.<T>query(conn, false, sql, rsh, (Object[]) null);
    }

    /**
     * Executes the given SELECT SQL query and returns a result object.
     * The <code>Connection</code> is retrieved from the
     * <code>DataSource</code> set in the constructor.
     * @param <T> The type of object that the handler returns
     * @param sql The SQL statement to execute.
     * @param rsh The handler used to create the result object from
     * the <code>ResultSet</code>.
     * @param params Initialize the PreparedStatement's IN parameters with
     * this array.
     * @return An object generated by the handler.
     * @throws SQLException if a database access error occurs
     */
    public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {
        final Connection conn = this.prepareConnection();

        return this.<T>query(conn, true, sql, rsh, params);
    }

    /**
     * Executes the given SELECT SQL without any replacement parameters.
     * The <code>Connection</code> is retrieved from the
     * <code>DataSource</code> set in the constructor.
     * @param <T> The type of object that the handler returns
     * @param sql The SQL statement to execute.
     * @param rsh The handler used to create the result object from
     * the <code>ResultSet</code>.
     *
     * @return An object generated by the handler.
     * @throws SQLException if a database access error occurs
     */
    public <T> T query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {
        final Connection conn = this.prepareConnection();

        return this.<T>query(conn, true, sql, rsh, (Object[]) null);
    }
    
    private <T> T query(final Connection conn, final boolean closeConn, final String sql, final ResultSetHandler<T> rsh, 
        final Object... params) throws SQLException {

        if (conn == null) {
            throw new SQLException("Null connection");
        }

        if (sql == null) {
            if (closeConn) {
                close(conn);
            }
            throw new SQLException("Null SQL statement");
        }

        if (rsh == null) {
            if (closeConn) {
                close(conn);
            }
            throw new SQLException("Null ResultSetHandler");
        }

        CallableStatement stmt = null;

        try {
            stmt = this.prepareCall(conn, sql);
            this.fillStatement(stmt, params);
            stmt.execute();
            return this.executeAndTreatResultOracleCursor(rsh, stmt, params);

        } catch (final SQLException e) {
            this.rethrow(e, sql, params);

        } finally {
            close(stmt);
            if (closeConn) {
                close(conn);
            }
        }
        
        return null;
    }
	
    
    /**
     * Execute an SP query without any replacement parameters.  The
     * caller is responsible for closing the connection.
     * @param conn The connection to execute the query in.
     * @param sql The SQL statement to execute.
     * @throws SQLException if a database access error occurs
     */
    public void execute(final Connection conn, final String sql) throws SQLException {
        this.execute(conn, false, sql, (Object[]) null);
    }
    
    /**
     * Execute an SP query without any replacement parameters.  The
     * caller is responsible for closing the connection.
     * @param conn The connection to execute the query in.
     * @param sql The SQL statement to execute.
     * @param params Initialize the PreparedStatement's IN parameters with
     * this array.
     * @throws SQLException if a database access error occurs
     */
    public void execute(final Connection conn, final String sql, Object...params) throws SQLException {
        this.execute(conn, false, sql, params);
    }

    /**
     * Executes the given SP query.
     * The <code>Connection</code> is retrieved from the
     * <code>DataSource</code> set in the constructor.
     * @param sql The SQL statement to execute.
     * @param params Initialize the PreparedStatement's IN parameters with
     * this array.
     * @throws SQLException if a database access error occurs
     */
    public void execute(final String sql, final Object... params) throws SQLException {
        final Connection conn = this.prepareConnection();

        this.execute(conn, true, sql, params);
    }
    
    /**
     * Executes the given SP query with no parameters.
     * The <code>Connection</code> is retrieved from the
     * <code>DataSource</code> set in the constructor.
     * @param sql The SQL statement to execute.
     * @throws SQLException if a database access error occurs
     */
    public void execute(final String sql) throws SQLException {
        final Connection conn = this.prepareConnection();

        this.execute(conn, true, sql, (Object[]) null);
    }
    
    
	private void execute(final Connection conn, final boolean closeConn, final String sql, final Object... params) throws SQLException {
		if (conn == null) {
            throw new SQLException("Null connection");
        }

        if (sql == null) {
            if (closeConn) {
                close(conn);
            }
            throw new SQLException("Null SQL statement");
        }

        CallableStatement stmt = null;

        try {
            stmt = this.prepareCall(conn, sql);
            this.fillStatement(stmt, params);
            stmt.execute();
            this.retrieveOutParameters(stmt, params);
        } catch (final SQLException e) {
            this.rethrow(e, sql, params);

        } finally {
            close(stmt);
            if (closeConn) {
                close(conn);
            }
        }

	}
	
	private <T> T executeAndTreatResultOracleCursor(final ResultSetHandler<T> rsh,
			CallableStatement stmt, final Object... params) throws SQLException {
		ResultSet rs = null;
		T handle = null;
		for (int i = 0; i < params.length; i++) {
			int index = i + 1;
			if (params[i] instanceof OutParameter) {
				@SuppressWarnings("rawtypes")
				OutParameter out = (OutParameter) params[i];
				if (out.getSqlType() == ORACLE_CURSOR_TYPE) {
					try {
						rs = this.wrap((ResultSet) stmt.getObject(index));
						handle = rsh.handle(rs);
					} finally {
						if (rs != null) rs.close();
					}
				}
			}
		}
		this.retrieveOutParameters(stmt, params);
		return handle;
	}
	
	/**
     * Factory method that creates and initializes a
     * <code>CallableStatement</code> object for the given SQL.
     * <code>QueryRunner</code> methods always call this method to prepare
     * callable statements for them. Subclasses can override this method to
     * provide special CallableStatement configuration if needed. This
     * implementation simply calls <code>conn.prepareCall(sql)</code>.
     *
     * @param conn
     *            The <code>Connection</code> used to create the
     *            <code>CallableStatement</code>
     * @param sql
     *            The SQL statement to prepare.
     * @return An initialized <code>CallableStatement</code>.
     * @throws SQLException
     *             if a database access error occurs
     */
    protected CallableStatement prepareCall(final Connection conn, final String sql)
            throws SQLException {

        return conn.prepareCall(sql);
    }

    /**
     * Fill the <code>PreparedStatement</code> replacement parameters with the
     * given objects.
     *
     * @param stmt
     *            PreparedStatement to fill
     * @param params
     *            Query replacement parameters; <code>null</code> is a valid
     *            value to pass in.
     * @throws SQLException
     *             if a database access error occurs
     */
    public void fillStatement(final PreparedStatement stmt, final Object... params)
            throws SQLException {

        // check the parameter count, if we can
        ParameterMetaData pmd = null;
        pmdKnownBroken = isPmdKnownBroken();

        if (!pmdKnownBroken) {
            try {
                pmd = stmt.getParameterMetaData();
                if (pmd == null) { // can be returned by implementations that don't support the method
                    pmdKnownBroken = true;
                } else {
                    final int stmtCount = pmd.getParameterCount();
                    final int paramsCount = params == null ? 0 : params.length;

                    if (stmtCount != paramsCount) {
                        throw new SQLException("Wrong number of parameters: expected "
                                + stmtCount + ", was given " + paramsCount);
                    }
                }
            } catch (final SQLFeatureNotSupportedException ex) {
                pmdKnownBroken = true;
            }
            // TODO see DBUTILS-117: would it make sense to catch any other SQLEx types here?
        }

        // nothing to do here
        if (params == null) {
            return;
        }

        CallableStatement call = null;
        if (stmt instanceof CallableStatement) {
            call = (CallableStatement) stmt;
        }

        for (int i = 0; i < params.length; i++) {
            if (params[i] != null) {
                if (call != null && params[i] instanceof OutParameter) {
                    ((OutParameter)params[i]).register(call, i + 1);
                } else {
                    stmt.setObject(i + 1, params[i]);
                }
            } else {
                // VARCHAR works with many drivers regardless
                // of the actual column type. Oddly, NULL and
                // OTHER don't work with Oracle's drivers.
                int sqlType = Types.VARCHAR;
                if (!pmdKnownBroken) {
                    // TODO see DBUTILS-117: does it make sense to catch SQLEx here?
                    try {
                        /*
                         * It's not possible for pmdKnownBroken to change from
                         * true to false, (once true, always true) so pmd cannot
                         * be null here.
                         */
                        sqlType = pmd.getParameterType(i + 1);
                    } catch (final SQLException e) {
                        pmdKnownBroken = true;
                    }
                }
                stmt.setNull(i + 1, sqlType);
            }
        }
    }

    /**
     * Set the value on all the {@link OutParameter} instances in the
     * <code>params</code> array using the OUT parameter values from the
     * <code>stmt</code>.
     * @param stmt the statement from which to retrieve OUT parameter values
     * @param params the parameter array for the statement invocation
     * @throws SQLException when the value could not be retrieved from the
     * statement.
     */
    @SuppressWarnings("rawtypes")
	private void retrieveOutParameters(final CallableStatement stmt, final Object[] params) throws SQLException {
        if (params != null) {
            for (int i = 0; i < params.length; i++) {
                if (params[i] instanceof OutParameter) {
                    OutParameter out = (OutParameter)params[i];
                    if (out.getSqlType() != ORACLE_CURSOR_TYPE)
                        ((OutParameter)params[i]).setValue(stmt, i + 1);
                }
            }
        }
    }
	
}
